# 尾递归和递归的区别

- 尾递归：进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。
- 非递归：下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。



尾递归和一般递归的不同点在于**对内存的占用**：

- 尾递归比普通递归多一个参数，这个参数是上一次调用函数得到的结果
- 所以，关键点在于尾递归每次调用都在收集结果，避免了**普通递归不收集结果**只能依次展开**消耗内存**的坏处。



实际上，尾递归只是一种形式。这种形式表达的代码可以被某些编译器优化。

尾递归的特殊形式决定了这种递归代码在执行过程中是可以不需要回溯的（通常递归都是需要回溯的）。如果编译器针对尾递归形式的代码做了这种优化，就可能把原本需要**线性复杂度**的内存空间执行过程改为用**常数复杂度**的空间完成。



## 优化点

尾递归主要是针对**栈内存空间**的优化。这个优化是 `O(n)` 到 `O(1)` 的；

对于**时间的优化**，实际上是由于对空间的优化导致内存分配的工作减少所产生的，是一个**常数优化**，不会带来质的变化。



## 代码示例

**实现一个 “计算斐波那契数列第n项” 函数**

- 第一版：最直接的递归实现（树形递归）

```js
const fib = (n) => {
  if(n <= 2) return 1;
  return fib(n - 1) + fib(n - 2);
}
```

- 第二版：迭代（循环）实现

```js
const fib = (n) => {
  let a = 1, b = 1;
  for(let i=0; i<n; i++) {
    let a_other = b, b_other = a+b;
    a = a_other;
    b = b_other;
  }
  return a
}
```

- 第三版：线性递归

```js
const fib = (n) => {
  const fib_iter = (a, b, n) => {
    if(n <= 1) return 1;
    return a + fib_iter(b + a+b, n-1); // 这里做个一个计算
  }
  return fib_iter(1, 1, n);
}
```

- 第四版：尾递归实现

```js
const fib = (n) => {
  const fib_iter = (a, b, n) => {
    if(n === 0) return a;
    return fib_iter(b, a+b, n-1); // 这里没有做计算，而是直接将结果返回了
  }
  return fib_iter(1, 1, n);
}
```

从第三版和第四版可以看出，**尾递归**就是把一个依赖上一层环境（上下文）的递归（第三版），转变为一个不依赖上一层环境的递归（第四版），转变的方法就是把需要用到的环境通过参数传递给下一层。

























































