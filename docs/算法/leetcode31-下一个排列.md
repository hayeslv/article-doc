# 下一个排列

[下一个排列](https://leetcode.cn/problems/next-permutation/)

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。

- 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
- 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

[4,5,2,6,3,1]

4 5 3 6 2 1

## 示例

```js
输入：nums = [1, 2, 3]
输出：[1, 3, 2]
```



## 思路

我们如果把数组当做一个数字的话，可以发现下一个数字总是比当前数字要大，除非当前数字已经是最大数字了。

我们以排列 `[5, 2, 8, 7, 3, 1]` 为例

- 从最右侧开始，找到第一个非升序的数字：`1 -> 3 -> 7 -> 8 -> 2`。找到数字 `2`
- 再从最右侧开始，跳过所以比 `2` 小的数字，找到第一个比 `2` 大的数字： `1 -> 3`，找到数字 `3`
- 将 `2` 和 `3` 交换位置，目前数组为：`[5, 3, 8, 7, 2, 1]`
- 可以看出，**数字 `3` 后面的数组内容**是降序的，我们将其反转：`[5, 3, 1, 2, 7, 8]`。这个数字就是我们所需的结果了。



**思考：**

1. 为什么第一步要找到从右开始的**第一个非升序数字**
   1. 假设数组从右开始，完全是升序，例如：`[8, 7, 5, 3, 2, 1]`，则当前就是最大数了，此时只需要返回它的反转就行了。
2. 找第二个数字的时候，为什么要跳过比**第一个数字**小的，找到比它大的数字
   1. 这是为了保持**第一个数字的位置（`i`）**后面的有序状态
   2. 可以看到数字 `2` 后面 `8, 7, 3, 1` 是依次降序的，找到 `3` 后和 `2` 交换位置，依旧可以保持位置 `i` 后面的降序状态 `8, 7, 2, 1`
   3. 降序状态的值是最大的，所以我们将其反转之后，它的值就是最小的了



## 代码实现

```js
var nextPermutation = function(nums) {
  // 先找到未按降序值的位置
  let i = nums.length -2; // i 从倒数第二个数开始(方便和其后面的数字对比)
  while(i>=0 && nums[i] >= nums[i+1]) {
    // 如果 i 比其后方的值大，则继续找
    i--;
  }
  // 此时i可能是 -1，也可能是找到了非降序的位置
  if(i>=0) {
    // 如果是找到了第一个非降序的位置，则还需要再找到第二个数字的位置（后方第一个比它大的数的位置）
    let j = nums.length - 1;
    while(j >= 0 && nums[i] >= nums[j]) j--;
    // 找到后交换位置
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }
  // 开始i后方的反转
  for(let p=i+1, q=nums.length-1; p<q; p++, q--) {
    [nums[p], nums[q]] = [nums[q], nums[p]];
  }
  return nums;
}
```

