# 正则表达式匹配

[正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

给你一个字符串 `s` 和一个字符串规律 `p`，请你来实现一个支持 `.` 和 `*` 的正则表达式匹配。

- `.` 匹配任意单个字符
- `*` 匹配零个或多个前面的那一元素

所谓匹配，就是要**涵盖整个字符串 `s`**，而不是部分字符串。



## 示例

- 示例1

```js
输入： s = "aa", p = "a"
输出： false
解释： "a" 无法匹配 "aa" 整个字符串。
```

- 示例2

```js
输入： s = "aa", p = "a*"
输出： true
解释： ".*" 表示可匹配零个或多个任意字符
```



## 思路

### 从左往右扫描

字符串后面是否跟着星号会影响结果，分析起来有点复杂

`s = "aab" p = "c*a*b"`

- 第一个字符 `a` 与 `c` 不匹配，但还要看 `c` 后面有没有跟着 `*`
  - `*` 的出现，可以把 `c` 干掉 --- 出现 0 次 `c`

示例2：`s = "ab" p = ".*"`

- `a` 与 `.` 匹配，也要看 `.` 后面是否跟着 `*`
- `.*` 能和任意多个字符串匹配

> 从左往右扫描，得考虑字符后面是否跟着 `*`



### 我们选择从右往左扫描

星号的前面肯定有一个字符，星号也只影响这一个字符，它就像一个拷贝器

`s = "aab" p = "c*a*b"`

```js
从最右边开始：`b` 和 `b` 匹配
`a` 和 `a*` 匹配
`a` 和 `a*` 匹配
`""` 和 `c*` 匹配
```

每次只用考虑末尾字符的匹配问题，**剩下的子串**的匹配就是子问题。只是最右端可能是特殊符号，需要分情况讨论而已。



### 通用的表示出子问题

大子串是否匹配，和剩余子串是否匹配，是规模不一样的同一个问题

```js
s(0, i)：下标从 0 到 i 的s串
p(0, j)：下标从 0 到 j 的p串
推断子问题：
i个字符的s串（`s(0, i-1)`）是否匹配 j 个字符的p串(`p(0, j-1)`)
`s(0, i-1)` 是否匹配 `p(0, j-1)`，用 dp[i][j] 表示（true 或 false）
```



### 情况1：`s[i-1]` 和 `p[j-1] `是匹配的

最右端的字符是匹配的，那么大问题的答案 = 剩余子串是否匹配

```js
s下标: [0, 1, 2, ***, i-2, i-1]
j下标：[0, 1, 2, ***, j-2, j-1]
if(s[i-1] === p[j-1] || p[j-1] === ".") // 满足这两个条件之一就代表 s[i-1] 和 p[j-1] 匹配上了
当前问题就等同于剩余的子问题了：dp[i][j] = dp[i-1][j-1] // 如果 dp[i-1][j-1] 是匹配的，那么 dp[i][j] 也是匹配的
```



### 情况2：`s[i-1]` 和 `p[j-1]` 是不匹配的

最右端不匹配，还不能判死刑：可能是 `p[j-1]` 为星号造成的不匹配，星号不是真实字符，它造成的不匹配不作数。

如果 `p[j-1]` 不是星号，那就是真的不匹配了。

```js
if(s[i-1] === p[j-1] || p[j-1] === ".") {
  // 匹配
} else {
  // 不匹配
  if(p[j-1] === "*") { // 还有救
    
  } else {
    dp[i][j] = false
  }
}
```



- `p[j-1] === "*"`，且 `s[i-1]` 和 `p[j-2]` 匹配

此条件下要考虑三种情况：`p[j-1]` 星号可以让 `p[j-2]` 在 `p` 串中消失、出现1次、出现 >= 2 次

只要其中一种情况使得剩余子串能匹配，那就能匹配

```js
// p[j-1] === "*" 的条件下
if(s[i-1] === p[j-2] || p[j-2] === ".") { //  s[i-1] 和 p[j-2] 匹配
  // 第一种情况：*让 p[j-2] 重复0次 => 考察 s(0, i-1) 和 p(0, j-3)
  dp[i][j] = dp[i][j-2]
  // 第二种情况：*让 p[j-2] 重复1次 => 考察 s(0, i-2) 和 p(0, j-3)
  dp[i][j] = dp[i-1][j-2]
  // 第三种情况：*让 p[j-2] 重复 >= 2 次，即 a* 是 n个a，我们拿出 p 中的一个 a，让它和 s[i-1] 抵消 => 考察 s(0, i-2) 和 p(0, j-1)
  dp[i][j] = dp[i-1][j]
}
```

> 第三种情况下：假设 `s` 的右端是一个 `a`，`p` 的右端是 `a*`
>
> - 星号不是真实字符，s、p是否匹配，要看s去掉末尾的a，p去掉末尾一个 a，剩下的是否匹配
> - 星号拷贝了 >= 2 个 a，拿掉一个，剩下 >=1 个 a，p末端依旧是 `a*` 没变
> - s 末尾的 a 被抵消了，继续考察 s(0, i-2) 和 p(0, i-1) 是否匹配



- `p[j-1] === "*"`，但 `s[i-1]` 和 `p[j-2]` 不匹配

此时还有救，`p[j-1]`的星号可以干掉 `p[j-2]`，继续考察 `s(0, i-1)` 和 `p(0, j-3)`



## 代码实现

```js
const isMatch = (s, p) => {
  if(s === null || p === null) return false; // 边界条件
  const sLen = s.length, pLen = p.length;
  // 初始化二维数组
  const dp = new Array(sLen+1); // 这里长度+1，让s和p都从空字符串开始
  for(let i=0; i<dp.length; i++) {
    // 初始化为false
    dp[i] = new Array(pLen+1).fill(false)
  }
  dp[0][0] = true; // 两个空字符串匹配
  for(let j=1; j<pLen+1; j++) {
    if(p[j-1] === "*") {
      // 当前s是空字符串，如果当前j的上一个(j-1) 是*，则当前是否匹配就等同于上一个的上一个(j-2) 是否匹配
      // 例如 s=[""] p=["", "a", "*"]
      dp[0][j] = dp[0][j-2]
    }
  }
  // 迭代
  for(let i=1; i<sLen+1; i++) {
    for(let j=1; j<pLen+1; j++) {
      if(s[i-1] === p[j-1] || p[j-1] === ".") {
        dp[i][j] = dp[i-1][j-1]
      } else if(p[j-1] === "*") {
        if(s[i-1] === p[j-2] || p[j-2] === ".") {
          dp[i][j] = dp[i][j-2] || dp[i-1][j-2] || dp[i-1][j]
        } else {
          dp[i][j] = dp[i][j-2]
        }
      }
    }
  }
  return dp[sLen][p]
}
```







































